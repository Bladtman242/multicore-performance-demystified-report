\chapter{Abstract}

\chapter{Introduction}
As software systems grow more complex, the tools and models we use to design
them grow more abstract. It seems that the more software designers wish to
accomplish in a single project, the further we move away from the bare metal of
modern hardware.

High-level programming languages like Java, F\#, and even C hide the
mind-boggling complexities of the hardware our programs run on, in favour of
simpler abstractions that make it easier (or even feasible) to design and
understand complex software systems. Even with low-level languages, entire
hardware components are abstracted away: In the x86-64 instruction set for
example, the CPU cache is essentially invisible to the programmer except for a
few prefetch instructions.

Such abstractions can betray the unsuspecting software designer, whose
understanding of the hardware they use is clouded by the abstractions they use
it through.

In \textit{A multicore performance mystery solved}\cite{mystery},
\citeauthor{mystery} brings to attention an example of such a betrayal: The
curious performance impact caused by false sharing of CPU cache-lines. Using a
k-means clustering implementation as example, he shows how a seemingly obvious
optimization makes the program 70\% slower in practice.

The aim of this report is to demystify multicore performance.
The intended audience is the graduate- or post-graduate level software designer
who is perhaps used to working on high-level, managed platforms (such as Java),
and who is unaccustomed to considerations of low-level hardware details, such as
cache coherence.

%In this report, I provide a description of hardware architecture I will provide
%further evidence of false sharing on Java runtime platforms across 3 different
%x86-64 machines. I will explain the 

\chapter{How to read this report}
